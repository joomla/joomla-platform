<?php
/**
 * @package     Joomla.Platform
 * @subpackage  Object
 *
 * @copyright   Copyright (C) 2005 - 2012 Open Source Matters, Inc. All rights reserved.
 * @license     GNU General Public License version 2 or later; see LICENSE
 */

defined('JPATH_PLATFORM') or die;

/**
 * JObject is a 'smart' value object.
 *
 * @package     Joomla.Platform
 * @subpackage  Object
 * @since       11.1
 */
class JObject implements IteratorAggregate, JsonSerializable
{
	/**
	 * An array of error messages or Exception objects.
	 *
	 * @var              array
	 * @deprecated       13.1   Use exception handling instead.
	 * @see              JError
	 * @since            11.1
	 */
	protected $_errors = array();

	/**
	 * The object properties.
	 *
	 * @var    array
	 * @since  12.3
	 */
	private $_properties = array();

	/**
	 * Class constructor.
	 *
	 * @param   mixed  $properties  Either and associative array or another object
	 *                              by which to set the initial properties of the new object.
	 *
	 * @since   11.1
	 * @throws  InvalidArgumentException
	 */
	public function __construct($properties = array())
	{
		// Check the properties input.
		if (!empty($properties))
		{
			// Bind the properties.
			$this->bind($properties);
		}
	}

	/**
	 * The magic get method is used to get an object property.
	 *
	 * This method is a public proxy for the protected getProperty method.
	 *
	 * Note: Magic __get does not allow recursive calls. This can be tricky
	 * because the error generated by recursing into __get is "Undefined
	 * property:  {CLASS}::{PROPERTY}" which is misleading. This is relevant
	 * for this class because requesting a non-visible property can trigger
	 * a call to a getter for that property. If the getter references the
	 * property directly in the object, it will cause a recursion into __get.
	 *
	 * @param   string  $property  The property name.
	 *
	 * @return  mixed  The property value, null otherwise.
	 *
	 * @see     JObject::getProperty()
	 * @since   12.3
	 */
	public function __get($property)
	{
		return $this->getProperty($property);
	}

	/**
	 * The magic isset method is used to check the state of an object property.
	 *
	 * @param   string  $property  The property name.
	 *
	 * @return  boolean  True if set, false otherwise.
	 *
	 * @since   12.3
	 */
	public function __isset($property)
	{
		return isset($this->_properties[$property]);
	}

	/**
	 * The magic set method is used to set an object property.
	 *
	 * This is a public proxy for the protected setProperty method.
	 *
	 * @param   string  $property  The property name.
	 * @param   mixed   $value     The property value.
	 *
	 * @return  void
	 *
	 * @see     JObject::setProperty()
	 * @since   12.3
	 */
	public function __set($property, $value)
	{
		$this->setProperty($property, $value);
	}

	/**
	 * The magic unset method is used to unset an object property.
	 *
	 * @param   string  $property  The property name.
	 *
	 * @return  void
	 *
	 * @since   12.3
	 */
	public function __unset($property)
	{
		unset($this->_properties[$property]);
	}

	/**
	 * Bind the object properties.
	 *
	 * @param   mixed    $properties   The object properties.
	 * @param   boolean  $updateNulls  True to bind null values, false to ignore null values.
	 *
	 * @return  JObject  The object.
	 *
	 * @since   12.3
	 * @throws  InvalidArgumentException
	 */
	public function bind($properties, $updateNulls = true)
	{
		// Check the properties data type.
		if (!is_array($properties) && !is_object($properties))
		{
			throw new InvalidArgumentException(sprintf('%s(%s)', __METHOD__, gettype($properties)));
		}

		// Check if the object is traversable.
		if ($properties instanceof Traversable)
		{
			// Convert iterator to array.
			$properties = iterator_to_array($properties);
		}
		// Check if the object needs to be converted to an array.
		elseif (is_object($properties))
		{
			// Convert properties to an array.
			$properties = (array) $properties;
		}

		// Bind the properties.
		foreach ($properties as $property => $value)
		{
			// Check if the value is null and should be bound.
			if ($value === null && !$updateNulls)
			{
				continue;
			}

			// Set the property.
			$this->setProperty($property, $value);
		}

		return $this;
	}

	/**
	 * Set a property value if not alreay set.
	 *
	 * @param   string  $property  The property to define.
	 * @param   mixed   $value     The property value.
	 *
	 * @return  mixed  If the property is defined, the current value, otherwise, the new value.
	 *
	 * @since   11.1
	 */
	public function def($property, $value = null)
	{
		// Check if the property is set.
		if (!isset($this->$property))
		{
			// Set the property.
			return $this->setProperty($property, $value);
		}

		// Get the property value.
		return $this->getProperty($property);
	}

	/**
	 * Dump the object properties recursively if appropriate.
	 *
	 * @param   integer  $depth   The maximum recursion depth (default = 3).
	 *                            For example, a depth of 0 will return a stdClass with all the properties in native form.
	 *                            A depth of 1 will recurse into the first level of properties only.
	 * @param   array    $dumped  An array of already serialized object to avoid infinite loops.
	 *
	 * @return  object  The object properties.
	 *
	 * @since   12.3
	 */
	public function dump($depth = 3, $dumped = null)
	{
		// Setup a container.
		$dump = new stdClass;

		// Get all available properties from the internal set.
		$properties = array_keys($this->_properties);

		// Dump all object properties.
		foreach ($properties as $property)
		{
			// Get the property.
			$dump->$property = $this->dumpProperty($property);
		}

		// Check if we should initialise the recursion tracker.
		if ($dumped === null)
		{
			$dumped = array();
		}

		// Add this object to the dumped stack.
		$dumped[] = spl_object_hash($this);

		// Make sure that we have not reached our maximum depth.
		if ($depth > 0)
		{
			// Handle recursive dump.
			foreach ($dump as &$value)
			{
				// Check if the object is also an dumpable object.
				if ($value instanceof JObject || $value instanceof JObjectList)
				{
					// Do not dump the property if it has already been dumped.
					if (!in_array(spl_object_hash($value), $dumped))
					{
						$value = $value->dump($depth - 1, $dumped);
					}
				}
				// Check if the object is a date.
				elseif (is_object($value) && $value instanceof JDate)
				{
					$value = (string) $value;
				}
				// Check if the object is a registry.
				elseif (is_object($value) && $value instanceof JRegistry)
				{
					$value = $value->toObject();
				}
			}
		}

		return $dump;
	}

	/**
	 * Get an object property or the default value if not set.
	 *
	 * @param   string  $property  The property to get.
	 * @param   mixed   $default   The default value if not set.
	 *
	 * @return  mixed  The value of the property or the default value.
	 *
	 * @deprecated  13.3  Access the property directly via `$value = $object->propertyName;`.
	 * @since       11.1
	 */
	public function get($property, $default = null)
	{
		if (isset($this->$property))
		{
			return $this->$property;
		}

		return $default;
	}

	/**
	 * Get the most recent error message.
	 *
	 * @param   integer  $i         Option error index.
	 * @param   boolean  $toString  Indicates if JError objects should return their error message.
	 *
	 * @return  string   Error message
	 *
	 * @deprecated  13.1   Use exception handling instead.
	 * @see         JError
	 * @since       11.1
	 */
	public function getError($i = null, $toString = true)
	{
		// Find the error
		if ($i === null)
		{
			// Default, return the last message
			$error = end($this->_errors);
		}
		elseif (!array_key_exists($i, $this->_errors))
		{
			// If $i has been specified but does not exist, return false
			return false;
		}
		else
		{
			$error = $this->_errors[$i];
		}

		// Check if only the string is requested
		if ($error instanceof Exception && $toString)
		{
			return (string) $error;
		}

		return $error;
	}

	/**
	 * Return all errors, if any.
	 *
	 * @return  array  Array of error messages or JErrors.
	 *
	 * @deprecated  13.1   Use exception handling instead.
	 * @see         JError
	 * @since       11.1
	 */
	public function getErrors()
	{
		return $this->_errors;
	}

	/**
	 * Get an object iterator.
	 *
	 * @return  ArrayIterator  An array iterator.
	 *
	 * @see     IteratorAggregate::getIterator()
	 * @since   12.3
	 */
	public function getIterator()
	{
		return new ArrayIterator($this->dump(0));
	}

	/**
	 * Get the object properties.
	 *
	 * @param   boolean  $public  If true, return only the public properties.
	 *
	 * @return  array  An array of object properties.
	 *
	 * @deprecated  13.3  Use `JObject->dump()` instead.
	 * @since       11.1
	 */
	public function getProperties($public = true)
	{
		// Get the properties.
		$properties = array_merge((array) $this->dump(), get_object_vars($this));

		// Check if we need to remove non-public variables. This is an old hack.
		if ($public)
		{
			// Iterate through the properties.
			foreach ($properties as $property => $value)
			{
				// Check if the property name starts with an underscore.
				if ('_' == substr($property, 0, 1))
				{
					// Remove the property.
					unset($properties[$property]);
				}
			}
		}

		return $properties;
	}

	/**
	 * Get the object properties to serialise with JSON.
	 *
	 * @return  string  An object that can be serialised by json_encode().
	 *
	 * @since   12.3
	 */
	public function jsonSerialize()
	{
		return $this->dump();
	}

	/**
	 * Set an object property.
	 *
	 * @param   string  $property  The property to set.
	 * @param   mixed   $value     The property value.
	 *
	 * @return  mixed  The previous value of the property.
	 *
	 * @deprecated  13.3  Access the property directly via `$object->propertyName = $newvalue;`.
	 * @since       11.1
	 */
	public function set($property, $value)
	{
		$previous = isset($this->$property) ? $this->$property : null;
		$this->$property = $value;

		return $previous;
	}

	/**
	 * Add an error message.
	 *
	 * @param   string  $error  Error message.
	 *
	 * @return  void
	 *
	 * @since       11.1
	 * @see         JError
	 * @deprecated  13.1   Use exception handling instead.
	 */
	public function setError($error)
	{
		array_push($this->_errors, $error);
	}

	/**
	 * Set the object properties based on a named array/hash or another object.
	 *
	 * @param   mixed  $properties  An associative array or another object.
	 *
	 * @return  boolean  True on success, false on failure.
	 *
	 * @see         set()
	 * @since       11.1
	 * @deprecated  13.3  Use JObject->bind instead.
	 */
	public function setProperties($properties)
	{
		try
		{
			// Bind the properties.
			$this->bind($properties);

			return true;
		}
		// Catch InvalidArgumentException to support backwards compatibility.
		catch (InvalidArgumentException $error)
		{
			return false;
		}
	}

	/**
	 * Dump an object property.
	 *
	 * @param   string  $property  The property name.
	 *
	 * @return  mixed  The property value.
	 *
	 * @since   12.3
	 */
	protected function dumpProperty($property)
	{
		return $this->getProperty($property);
	}

	/**
	 * Get an object property.
	 *
	 * @param   string  $property  The property name.
	 *
	 * @return  mixed  The property value.
	 *
	 * @see     JObject::__get()
	 * @since   12.3
	 */
	protected function getProperty($property)
	{
		// Get the raw value.
		$value = array_key_exists($property, $this->_properties) ? $this->_properties[$property] : null;

		return $value;
	}

	/**
	 * Set an object property.
	 *
	 * @param   string  $property  The property name.
	 * @param   mixed   $value     The property value.
	 *
	 * @return  mixed  The property value.
	 *
	 * @see     JObject::__set()
	 * @since   12.3
	 */
	protected function setProperty($property, $value)
	{
		/*
		 * Check if the property starts with a null byte. If so, discard it because a later attempt to try to access it
		 * can cause a fatal error. See http://us3.php.net/manual/en/language.types.array.php#language.types.array.casting
		 */
		if (strpos($property, "\0") === 0)
		{
			return null;
		}

		// Set the value.
		$this->_properties[$property] = $value;

		return $value;
	}
}

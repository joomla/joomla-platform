<?php
/**
 * @package     Joomla.Platform
 * @subpackage  Data
 *
 * @copyright   Copyright (C) 2005 - 2012 Open Source Matters, Inc. All rights reserved.
 * @license     GNU General Public License version 2 or later; see LICENSE
 */

defined('JPATH_PLATFORM') or die;

/**
 * JData is a 'smart' value object.
 *
 * @package     Joomla.Platform
 * @subpackage  Data
 * @since       12.3
 */
class JData implements JDataDumpable, IteratorAggregate, JsonSerializable
{
	/**
	 * The object properties.
	 *
	 * @var    array
	 * @since  12.3
	 */
	private $_properties = array();

	/**
	 * Class constructor.
	 *
	 * @param   mixed  $properties  Either and associative array or another object
	 *                              by which to set the initial properties of the new object.
	 *
	 * @since   11.1
	 * @throws  InvalidArgumentException
	 */
	public function __construct($properties = array())
	{
		// Check the properties input.
		if (!empty($properties))
		{
			// Bind the properties.
			$this->bind($properties);
		}
	}

	/**
	 * The magic get method is used to get an object property.
	 *
	 * This method is a public proxy for the protected getProperty method.
	 *
	 * Note: Magic __get does not allow recursive calls. This can be tricky
	 * because the error generated by recursing into __get is "Undefined
	 * property:  {CLASS}::{PROPERTY}" which is misleading. This is relevant
	 * for this class because requesting a non-visible property can trigger
	 * a call to a getter for that property. If the getter references the
	 * property directly in the object, it will cause a recursion into __get.
	 *
	 * @param   string  $property  The property name.
	 *
	 * @return  mixed  The property value, null otherwise.
	 *
	 * @see     JData::getProperty()
	 * @since   12.3
	 */
	public function __get($property)
	{
		return $this->getProperty($property);
	}

	/**
	 * The magic isset method is used to check the state of an object property.
	 *
	 * @param   string  $property  The property name.
	 *
	 * @return  boolean  True if set, false otherwise.
	 *
	 * @since   12.3
	 */
	public function __isset($property)
	{
		return isset($this->_properties[$property]);
	}

	/**
	 * The magic set method is used to set an object property.
	 *
	 * This is a public proxy for the protected setProperty method.
	 *
	 * @param   string  $property  The property name.
	 * @param   mixed   $value     The property value.
	 *
	 * @return  void
	 *
	 * @see     JData::setProperty()
	 * @since   12.3
	 */
	public function __set($property, $value)
	{
		$this->setProperty($property, $value);
	}

	/**
	 * The magic unset method is used to unset an object property.
	 *
	 * @param   string  $property  The property name.
	 *
	 * @return  void
	 *
	 * @since   12.3
	 */
	public function __unset($property)
	{
		unset($this->_properties[$property]);
	}

	/**
	 * Bind the object properties.
	 *
	 * @param   mixed    $properties   The object properties.
	 * @param   boolean  $updateNulls  True to bind null values, false to ignore null values.
	 *
	 * @return  JData  The object.
	 *
	 * @since   12.3
	 * @throws  InvalidArgumentException
	 */
	public function bind($properties, $updateNulls = true)
	{
		// Check the properties data type.
		if (!is_array($properties) && !is_object($properties))
		{
			throw new InvalidArgumentException(sprintf('%s(%s)', __METHOD__, gettype($properties)));
		}

		// Check if the object is traversable.
		if ($properties instanceof Traversable)
		{
			// Convert iterator to array.
			$properties = iterator_to_array($properties);
		}
		// Check if the object needs to be converted to an array.
		elseif (is_object($properties))
		{
			// Convert properties to an array.
			$properties = (array) $properties;
		}

		// Bind the properties.
		foreach ($properties as $property => $value)
		{
			// Check if the value is null and should be bound.
			if ($value === null && !$updateNulls)
			{
				continue;
			}

			// Set the property.
			$this->setProperty($property, $value);
		}

		return $this;
	}

	/**
	 * Set a property value if not alreay set.
	 *
	 * @param   string  $property  The property to define.
	 * @param   mixed   $value     The property value.
	 *
	 * @return  mixed  If the property is defined, the current value, otherwise, the new value.
	 *
	 * @since   11.1
	 */
	public function def($property, $value = null)
	{
		// Check if the property is set.
		if (!isset($this->$property))
		{
			// Set the property.
			return $this->setProperty($property, $value);
		}

		// Get the property value.
		return $this->getProperty($property);
	}

	/**
	 * Dump the object properties recursively if appropriate.
	 *
	 * @param   integer           $depth   The maximum recursion depth (default = 3).
	 *                                     For example, a depth of 0 will return a stdClass with all the properties in native
	 *                                     form. A depth of 1 will recurse into the first level of properties only.
	 * @param   SplObjectStorage  $dumped  An array of already serialized object to avoid infinite loops.
	 *
	 * @return  object  The object properties.
	 *
	 * @since   12.3
	 */
	public function dump($depth = 3, SplObjectStorage $dumped = null)
	{
		// Check if we should initialise the recursion tracker.
		if ($dumped === null)
		{
			$dumped = new SplObjectStorage;
		}

		// Add this object to the dumped stack.
		$dumped->attach($this);

		// Setup a container.
		$dump = new stdClass;

		// Dump all object properties.
		foreach (array_keys($this->_properties) as $property)
		{
			// Get the property.
			$dump->$property = $this->dumpProperty($property, $depth, $dumped);
		}

		return $dump;
	}

	/**
	 * Get an object iterator.
	 *
	 * @return  ArrayIterator  An array iterator.
	 *
	 * @see     IteratorAggregate::getIterator()
	 * @since   12.3
	 */
	public function getIterator()
	{
		return new ArrayIterator($this->dump(0));
	}

	/**
	 * Get the object properties to serialise with JSON.
	 *
	 * @return  string  An object that can be serialised by json_encode().
	 *
	 * @since   12.3
	 */
	public function jsonSerialize()
	{
		return $this->dump();
	}

	/**
	 * Dump an object property.
	 *
	 * @param   string   $property  The property name.
	 * @param   integer  $depth     The current depth.
	 *
	 * @return  mixed  The property value.
	 *
	 * @since   12.3
	 */
	protected function dumpProperty($property, $depth, SplObjectStorage $dumped)
	{
		$value = $this->getProperty($property);

		if ($depth > 0)
		{
			// Check if the object is also an dumpable object.
			if ($value instanceof JData || $value instanceof JDataSet)
			{
				// Do not dump the property if it has already been dumped.
				if (!$dumped->contains($value))
				{
					$value = $value->dump($depth - 1, $dumped);
				}
			}
			// Check if the object is a date.
			if ($value instanceof JDate)
			{
				$value = (string) $value;
			}
			// Check if the object is a registry.
			elseif ($value instanceof JRegistry)
			{
				$value = $value->toObject();
			}
		}

		return $value;
	}

	/**
	 * Get an object property.
	 *
	 * @param   string  $property  The property name.
	 *
	 * @return  mixed  The property value.
	 *
	 * @see     JData::__get()
	 * @since   12.3
	 */
	protected function getProperty($property)
	{
		// Get the raw value.
		$value = array_key_exists($property, $this->_properties) ? $this->_properties[$property] : null;

		return $value;
	}

	/**
	 * Set an object property.
	 *
	 * @param   string  $property  The property name.
	 * @param   mixed   $value     The property value.
	 *
	 * @return  mixed  The property value.
	 *
	 * @see     JData::__set()
	 * @since   12.3
	 */
	protected function setProperty($property, $value)
	{
		/*
		 * Check if the property starts with a null byte. If so, discard it because a later attempt to try to access it
		 * can cause a fatal error. See http://us3.php.net/manual/en/language.types.array.php#language.types.array.casting
		 */
		if (strpos($property, "\0") === 0)
		{
			return null;
		}

		// Set the value.
		$this->_properties[$property] = $value;

		return $value;
	}
}
